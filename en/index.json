[{"content":"安装过程 首先需要安装Hugo，安装Hugo需要利用一个包管理工具，对于Windows系统Hugo可以直接用Winget来安装，打开终端输入\nwinget install Hugo.Hugo.Extended 如果提示not recognized as the name of cmdlet，查找C:\\Users\\Username\\AppData\\Local\\Microsoft\\WindowsApps目录下有没有winget.exe，如果存在则添加这个目录到环境变量，否则去应用商店找winget，这是windows官方提供的windows包管理工具，一般系统里都会自带。\nHugo的tutorial介绍了如何创建一个项目，其中step2（.yml的config文件）和step3（下载主题）要根据PaperMod的guide来配置。\n文件介绍 content：用于放博客内容 data：不用管 layouts：自定义的HTML public：项目导出文件 resources：自定义的CSS和JavaScript static：存放的图片 themes：主题 进入themes/PaperMod则是PaperMod的相关代码，比较主要的目录有：\nassets：PaperMod的CSS和JavaScript代码 layouts：PaperMod的HTML Config.yml 建议直接按照【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)进行配置。\n创建文章 在终端输入hugo new 文章名称.md就会在content文件夹下创建markdown文件，文章头部信息可以修改这篇文章的属性，建议按照【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)进行配置。\n本地预览 在终端输入hugo server -D启动，建议新建一个.bat文件执行这条指令。 启动服务器后，打开浏览器，本地预览网址为localhost:1313。 网站部署 我用的是GitHub Page。\n在GitHub里创建一个仓库，名称叫做你的名字.github.io。 当我们本地预览没问题了的时候，在终端输入hugo -F --cleanDestinationDir，在public文件夹下就会生成输出文件。 我们将public文件夹作为GitHub Page的本地仓库，每次生成输出文件就推送到GitHub上，GitHub Page就会自动帮我们部署了。 多语言 如果我们想要使用多语言（中英为例），就需要在content文件夹下准备两个文件夹，例如Chinese和English，一个放中文，另一个放英文。 在config.yml中需要做以下修改： defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; contentDir: content/English zh: languageName: \u0026#34;中文\u0026#34; contentDir: content/Chinese 可以用它将中文翻译为英文。 搜索功能 分别在中英文的文件夹下创建search.md（hugo new search.md），修改文件头为： title: \u0026#34;Search\u0026#34; date: ... draft: false layout: search config.yml中添加： menu: main: -identifier: Search name: Search url: search weight: ... Hover 主要在themes/PaperMod/assets/css/common/header.css中修改。\n左上角Home的hover： .logo a:hover { transition: 0.15s; color: grey; } 社交媒体hover： svg:hover { transition: 0.15s; } .social-icons a:nth-child(1) svg:hover{ color: #C84370 !important; } .social-icons a:nth-child(2) svg:hover { color: grey !important; } ... nth-child可以设置各个图标的hover颜色。\n黑夜模式和白天模式的hover： #moon:hover { transition: 0.15s; color: deepskyblue; } #sun:hover { transition: 0.15s; color: gold; } menu中链接hover： #menu a:hover { transition: 0.15s; color: grey; } 按钮hover： 在themes/PaperMod/assets/css/common/profile-mode.css中修改：\n.button:hover { -webkit-transform: scale(1.1); -moz-transform: scale(1.1); -ms-transform: scale(1.1); -o-transform: scale(1.1); /* box-shadow: 0 0 0 1px grey; */ transform: scale(1.1) translateZ(0) translate3d(0, 0, 0) rotate(0.01deg); } 自定义社交媒体图标 利用SVG图标制作网站，比如icons8，找到我们需要的图标，例如微信。 可以利用左侧菜单栏的Stroke调节线条粗细。 点击download，SVG Embed，自定义图标大小为24*24，然后点击copy HTML。 在themes/PaperMod/layouts/partials/svg.html中粘贴复制的HTML。 需要修改为fill=currentColor stroke=currentColor，才能适应白天黑夜切换。 微信和微博的图标： {{- else if (eq $icon_name \u0026#34;wechat\u0026#34;) -}} \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 50 50\u0026#34;\u0026gt; \u0026lt;g fill=\u0026#34;currentColor\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M 19 6 C 9.746094 6 2 12.359375 2 20.5 C 2 24.894531 4.292969 28.679688 7.835938 31.324219 L 5.179688 39.304688 L 13.472656 34.167969 C 15.1875 34.707031 17.082031 35 19 35 C 19.746094 35 20.472656 34.945313 21.195313 34.863281 C 23.378906 39.105469 28.328125 42 34 42 C 35.722656 42 37.316406 41.675781 38.796875 41.234375 L 45.644531 45.066406 L 43.734375 38.515625 C 46.3125 36.375 48 33.394531 48 30 C 48 23.789063 42.597656 18.835938 35.75 18.105469 C 34.398438 11.125 27.324219 6 19 6 Z M 19 8 C 26.308594 8 32.328125 12.351563 33.703125 18.011719 C 26.183594 18.148438 20 23.355469 20 30 C 20 31.019531 20.160156 32.003906 20.4375 32.941406 C 19.964844 32.980469 19.484375 33 19 33 C 17.101563 33 15.199219 32.710938 13.632813 32.15625 L 13.183594 32 L 8.820313 34.699219 L 10.1875 30.59375 L 9.5625 30.171875 C 6.082031 27.820313 4 24.445313 4 20.5 C 4 13.640625 10.65625 8 19 8 Z M 13 14 C 11.898438 14 11 14.898438 11 16 C 11 17.101563 11.898438 18 13 18 C 14.101563 18 15 17.101563 15 16 C 15 14.898438 14.101563 14 13 14 Z M 25 14 C 23.898438 14 23 14.898438 23 16 C 23 17.101563 23.898438 18 25 18 C 26.101563 18 27 17.101563 27 16 C 27 14.898438 26.101563 14 25 14 Z M 34 20 C 40.746094 20 46 24.535156 46 30 C 46 32.957031 44.492188 35.550781 42.003906 37.394531 L 41.445313 37.8125 L 42.355469 40.933594 L 39.105469 39.109375 L 38.683594 39.25 C 37.285156 39.71875 35.6875 40 34 40 C 27.253906 40 22 35.464844 22 30 C 22 24.535156 27.253906 20 34 20 Z M 29.5 26 C 28.699219 26 28 26.699219 28 27.5 C 28 28.300781 28.699219 29 29.5 29 C 30.300781 29 31 28.300781 31 27.5 C 31 26.699219 30.300781 26 29.5 26 Z M 38.5 26 C 37.699219 26 37 26.699219 37 27.5 C 37 28.300781 37.699219 29 38.5 29 C 39.300781 29 40 28.300781 40 27.5 C 40 26.699219 39.300781 26 38.5 26 Z\u0026#34;\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; {{- else if (eq $icon_name \u0026#34;weibo\u0026#34;) -}} \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 172 172\u0026#34;\u0026gt; \u0026lt;g fill=\u0026#34;currentColor\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M120.4,20.64c-2.67406,0 -5.25406,0.26875 -7.74,0.71219c-1.86781,0.3225 -3.1175,2.10969 -2.795,3.9775c0.3225,1.88125 2.10969,3.13094 3.9775,2.80844c2.17688,-0.38969 4.35375,-0.61813 6.5575,-0.61813c20.93563,0 37.84,16.90438 37.84,37.84c0,4.52844 -0.83312,8.85531 -2.31125,12.91344c-0.45687,1.16906 -0.25531,2.48594 0.5375,3.45344c0.80625,0.9675 2.05594,1.42437 3.29219,1.19594c1.23625,-0.22844 2.24406,-1.11531 2.63375,-2.29781c1.73344,-4.75687 2.72781,-9.87656 2.72781,-15.265c0,-24.65781 -20.06219,-44.72 -44.72,-44.72zM120.4,41.28c-1.46469,0 -2.84875,0.14781 -4.16562,0.37625c-1.86781,0.33594 -3.13094,2.10969 -2.795,3.99094c0.3225,1.86781 2.10969,3.1175 3.9775,2.795c1.00781,-0.17469 2.00219,-0.28219 2.98312,-0.28219c9.54063,0 17.2,7.65938 17.2,17.2c0,2.05594 -0.37625,4.01781 -1.06156,5.87219c-0.645,1.78719 0.28219,3.7625 2.06938,4.4075c1.78719,0.645 3.7625,-0.26875 4.4075,-2.05594c0.92719,-2.55312 1.46469,-5.32125 1.46469,-8.22375c0,-13.26281 -10.81719,-24.08 -24.08,-24.08zM72.46844,42.6775c-11.04562,0 -27.50656,8.66719 -42.18031,23.07219c-14.76781,14.76781 -23.40813,30.24781 -23.40813,43.57781c0,25.9075 33.12344,41.3875 65.88406,41.3875c42.47594,0 70.90969,-24.46969 70.90969,-43.91375c0,-11.87875 -10.07812,-18.35562 -19.08125,-21.23125c-2.15,-0.72562 -3.60125,-1.08844 -2.52625,-3.96406c0.72563,-1.73344 1.77375,-5.01219 1.77375,-9.36594c0,-4.945 -3.44,-9.23156 -10.32,-9.9975c-0.79281,-0.08062 -2.13656,-0.14781 -3.82969,-0.14781c-5.6975,0 -15.48,0.71219 -22.52125,3.66844c0,0 -1.38406,0.57781 -2.49938,0.57781c-1.00781,0 -1.80062,-0.48375 -1.11531,-2.37844c2.52625,-7.91469 2.16344,-14.39156 -1.80063,-18.00625c-2.23062,-2.23062 -5.42875,-3.27875 -9.28531,-3.27875zM72.46844,49.5575c1.43781,0 3.37281,0.215 4.43438,1.26313l0.1075,0.12094l0.12094,0.1075c1.54531,1.41094 1.51844,5.61687 -0.09406,10.72312c-1.38406,3.99094 -0.09406,6.75906 0.81969,8.04906c1.51844,2.16344 4.00437,3.39969 6.81281,3.39969c2.28438,0 4.39406,-0.79281 5.14656,-1.11531c5.50938,-2.31125 13.88094,-3.13094 19.87406,-3.13094c1.53187,0 2.60687,0.05375 3.07719,0.1075c2.78156,0.30906 4.1925,1.37063 4.1925,3.15781c0,3.23844 -0.77937,5.61688 -1.23625,6.73219l-0.05375,0.1075l-0.04031,0.09406c-1.075,2.88906 -1.06156,5.50938 0.04031,7.80719c1.62594,3.39969 4.82406,4.46125 6.54406,5.03906l0.28219,0.09406c5.34813,1.70656 14.2975,5.88562 14.2975,14.68719c0,7.90125 -6.81281,17.65688 -18.90656,25.16844c4.77031,-5.54969 7.47125,-12.05344 7.47125,-19.05437c0,-21.01625 -24.37562,-37.47719 -55.48344,-37.47719c-31.10781,0 -55.47,16.46094 -55.47,37.47719c0,0.645 0.01344,1.27656 0.05375,1.90812c-0.45687,-1.76031 -0.69875,-3.60125 -0.69875,-5.49594c0,-11.16656 7.59219,-24.91312 21.33875,-38.65969c14.86188,-14.59313 29.48188,-21.11031 37.36969,-21.11031zM69.875,82.33156c26.84813,0 48.60344,13.69281 48.60344,30.59719c0,16.89094 -21.75531,30.58375 -48.60344,30.58375c-26.83469,0 -48.59,-13.69281 -48.59,-30.58375c0,-16.90437 21.75531,-30.59719 48.59,-30.59719zM66.27375,89.52063c-10.38719,0.08062 -20.47875,5.76469 -24.85937,14.52594c-5.40188,11.13969 -0.36281,23.38125 12.59094,27.33187c12.95375,4.31344 28.42031,-2.16344 33.82219,-14.02875c5.38844,-11.5025 -1.43781,-23.73062 -14.39156,-26.95562c-2.365,-0.61813 -4.77031,-0.88688 -7.16219,-0.87344zM71.63531,104.06c1.98875,0 3.60125,1.59906 3.60125,3.58781c0,1.98875 -1.6125,3.60125 -3.60125,3.60125c-1.98875,0 -3.60125,-1.6125 -3.60125,-3.60125c0,-1.98875 1.6125,-3.58781 3.60125,-3.58781zM56.47781,107.64781c1.12875,0.01344 2.2575,0.18812 3.31906,0.55094c4.60906,1.46469 6.02,5.83188 3.18469,9.47344c-2.4725,3.64156 -8.12969,5.45563 -12.38938,3.64156c-4.23281,-1.81406 -5.29437,-6.19469 -2.82187,-9.46c1.85437,-2.74125 5.30781,-4.24625 8.7075,-4.20594z\u0026#34;\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;path d=\u0026#34;\u0026#34; fill=\u0026#34;none\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; 目录栏目放侧边 详见：Hugo博客目录放在侧边 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)。\nMarkdown渲染风格 详见：折腾 Hugo \u0026amp; PaperMod 主题 - Dvel\u0026rsquo;s Blog\n流量统计 这里我使用了不蒜子，在themes/PaperMod/layouts/partials/svg.html中修改：\n{{- if not (.Param \u0026#34;hideFooter\u0026#34;) }} \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; {{- if site.Copyright }} ... {{- end }} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\u0026#34;\u0026gt; Visitors: \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Views: \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/footer\u0026gt; {{- end }} 插入B站，YouTube视频或PPT 详见：Hugo博客自定义shortcodes | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n插入音乐播放器 详见：Hugo插入音乐播放器\n隐藏歌词：lrc-type=0\n修改全局字体 首先找到喜欢的字体，然后可以在Google Fonts中查询字体，我目前的文章字体为CodeNewRoman。Google Fonts会生成HTML和css，将HTML插入到themes/PaperMod/layouts/partials/extend_head.html中，将CSS插入到themes/PaperMod/assets/css/extended/blank.css。\nbody { font-family: \u0026#39;Code New Roman\u0026#39;, sans-serif; font-size: 1rem; line-height: 1.5; margin: 0; } 修改代码字体 与全局字体类似，区别为CSS代码插入的位置不同。\n.post-content pre, code { font-family: \u0026#39;Code New Roman\u0026#39;, sans-serif; max-height: 40rem; } 评论功能 详见：Hugo博客添加Twikoo评论 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n关于Outlook邮箱配置 详见：关于邮箱配置的问题？ · Discussion #249 · imaegoo/twikoo (github.com)\n自定义邮箱回复模板 详见：自定义Twikoo邮件通知模板 | Guo Le\u0026rsquo;s Blog\n代码高亮 在两个地方修改\n一个是themes/PaperMod/assets/css/common/post-single.css：\n.post-content pre code { display: block; margin: auto 0; padding: 10px; /* 主要代码颜色 */ color: #abb2bf; font-weight: 200; overflow-x: auto; word-break: break-all; } 另一个是在themes/PaperMod/assets/css/hljs/an-old-hope.min.css，这是我自己修改的：\n/* 注释 */ .hljs-comment, .hljs-quote { font-weight: 200; color: #7f848e; } .hljs-deletion, /* html标签 */ .hljs-name, .hljs-regexp, .hljs-tag { font-weight: 200; color: #e06c75; } /* html属性 */ .hljs-tag { font-weight: 200; color: #d19a66; } /* css类名 */ .hljs-template-variable, .hljs-variable, .hljs-selector-class, .hljs-selector-id { font-weight: 200; color: #a9b600; } /* 内置函数 */ .hljs-built_in, .hljs-builtin-name { font-weight: 200; color: #56b6c2; } /* 函数输入 */ .hljs-params { font-weight: 200; color: #e5c07b; } /* 数字 */ .hljs-number { font-weight: 200; color: #d19a66; } /* css属性 */ .hljs-attribute { font-weight: 200; color: #ee7c2b; } /* 字符串 */ .hljs-addition, .hljs-bullet, .hljs-symbol, .hljs-string { font-weight: 200; color: #98c379; } /* 函数名称 */ .hljs-section, .hljs-title { font-weight: 200; color: #56b6c2; } /* 关键字 */ .hljs-keyword, .hljs-selector-tag, .hljs-literal, .hljs-link, .hljs-meta, .hljs-type { font-weight: 200; color: #c678dd; } .hljs { display: block; overflow-x: auto; background: #1c1d21; color: #c0c5ce; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: 700; } /* 选中时的背景颜色 */ .hljs ::selection, .hljs::selection { background-color: #3d4556; } 代码边框圆角 themes/PaperMod/assets/css/common/post-single.css中修改：\n.post-content .highlight pre { background-color: var(--theme) !important; margin: 0; } 添加友链 详见：Hugo博客添加友链 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n","permalink":"https://kyxie.github.io/zh/blog/tech/papermod/","summary":"安装过程 首先需要安装Hugo，安装Hugo需要利用一个包管理工具，对于Windows系统Hugo可以直接用Winget来安装，打开终端输入 winget","title":"Hugo + PaperMod搭建技术博客"},{"content":"Character 判断是否为字母或数字：\nboolean res = Character.isLetterOrDigit(char); 转小写：\nchar res = Character.toLowerCase(char); 下一个字符：\n\u0026#39;b\u0026#39; == (char) (\u0026#39;a\u0026#39; + 1); Integer 最大值最小值：\nint max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; 比较相等：\nInteger a = 1; Integer b = 1; a == b;\t// true Integer c = 200; Integer d = 200; c == d;\t// false Objects.equals(c, d);\t// true Array 创建数组：\nint[] array = new int[5]; int[] array = new int[]{1,2,3,4}; int[] array = {1,2,3,4}; 引用：\narray[3]; 获取长度：\narray.length; 排序：\nArrays.sort(array); // int[] 不能直接做降序排列 // 想做降序排列只能用Integer[] Integer[] array = new Integer[2]; Arrays.sort(array, Comparitor.naturalOrder());\t// 升序排列 Arrays.sort(array, Comparator.reverseOrder());\t// 降序排列 二维数组排序：\nint[][] array = new int[][]{{1, 2}, {2, 3}}; Arrays.sort(array, (o1, o2) -\u0026gt; o1[0] - o2[0]);\t// 按照二维数组的第一个元素从小到大排序 Arrays.sort(array, (o1, o2) -\u0026gt; o1[1] - o2[1]);\t// 按照二维数组的第二个元素从小到大排序 打印：\nSystem.out.println(Arrays.toString(array)); 填满：\nint[] array = new int[]; int num; Arrays.fill(array, num);\t// array全部元素等于num String 创建字符串：\nString string = \u0026#34;java\u0026#34;; 指定位置的字符\nchar charAt3 = string.charAt(3);\t// charAt3 = \u0026#39;a\u0026#39; 字符串相等：\nString string1 = \u0026#34;abc\u0026#34;; String string2 = \u0026#34;abc\u0026#34;; string1.equals(string2); 字符串转整数：\nString string = \u0026#34;123\u0026#34;; int integer = Integer.parseInt(string); 字符串长度：\nint length = string.length(); 截取字符串：\nString sb = \u0026#34;abcdef\u0026#34;; String str = sb.substring(0, 1);\t// str = \u0026#34;a\u0026#34;; String str = sb.substring(1);\t// str = \u0026#34;bcdef\u0026#34;;\t如果只有一个参数则为beginIndex 字符的位置：\nString str = \u0026#34;abc\u0026#34;; int index = str.indexOf(b);\t// index = 1 字符串转字符数组：\nString str; char[] temp = str.toCharArray(); 字符串分割：\nString str = \u0026#34;hello world\u0026#34;; String[] word = str.split(\u0026#34; \u0026#34;);\t// word = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] // 这里必须是字符串 // 如果有两个空格连在一起，会在数组中加入一个\u0026#34;\u0026#34;（空字符串） 将字符串数组合并为长字符串（中间插入）：\nString[] words = new String[]{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; String str = String.join(\u0026#34; \u0026#34;, words); // str = \u0026#34;hello world\u0026#34;; 字符串替换：\nString str = \u0026#34;a! b\u0026#34;; str = str.replace(\u0026#34;!\u0026#34;, \u0026#34; \u0026#34;);\t// str = \u0026#34;a b\u0026#34;; // 字符或者字符串都可以替换 删除字符串头尾的空格：\nString str = \u0026#34; abc \u0026#34;; str.trim();\t// str = \u0026#34;abc\u0026#34; Stack 创建 stack：\nDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;Integer\u0026gt;(); 栈顶：\nstack.peek() 入栈：\nstack.push(); 出栈：\nstack.pop(); 栈是否为空：\nstack.isEmpty(); 栈的长度：\nstack.size(); ArrayList 创建列表：\nList\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(); List\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(Arrays.asList(1, 2, 3, 4));\t// 初始化值 添加元素：\narray.add(1); 指定位置的元素：\narray.get(0); 列表中是否存在某元素：\narray.contains(0); 删除列表元素：\narray.remove(0);\t// 删除array[0] array.remove(Integer.valueOf(0));\t// 删除元素0 列表大小：\narray.size(); 判断列表是否为空：\narray.isEmpty(); 清空列表：\narray.clear(); 升序排列：\narray.sort(Comparator.naturalOrder()); 降序排列：\narray.sort(Comparator.reverseOrder()); 修改值：\narray.set(int index, int value); 反转：\nCollections.reverse(array); HashMap 创建一个哈希映射：\nMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); 存储键值对（修改键值对）：\nmap.put(key, value); 获取 key 的内容：\nmap.get(key); 如果不知道有没有内容：\nmap.getOrDefault(key, default); // 如果存在key，返回key的值 // 如果不存在key，返回default map.put(key, map.getOrDefault(key, 0) + 1); 查询是否存在 key：\nmap.containsKey(key); 遍历键值对：\n// 遍历key for (Integer key : map.keySet()) { } // 遍历value for (Integer value : map.values()) { } 是否为空：\nmap.isEmpty(); 删除Key：\nmap.remove(key); 大小：\nmap.size(); 排序：\nMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;();\t// 创建一个哈希映射 List\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; mapList = new ArrayList\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;(map.entrySet());\t// 我们无法对HashMap排序，需要把HashMap转换为ArrayList再排序 Collections.sort(mapList, new Comparator\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;() { public int compare(Map.Entry\u0026lt;Integer, Integer\u0026gt; o1, Map.Entry\u0026lt;Integer, Integer\u0026gt; o2) { return (o2.getValue() - o1.getValue());\t// 按照值的大小，从大到小排序 } }); mapList.get(i).getKey();\t// 排序后第i个的键 mapList.get(i).getValue();\t// 排序后第i个的值 HashSet 创建哈希表：\nSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;Integer\u0026gt;(); 添加元素：\nset.add(); 判断元素是否存在：\nset.contains();\t// HashSet查找元素要优于ArrayList 删除元素：\nset.remove(); 清空：\nset.clear(); 遍历：\nfor (int temp : set) { ... } StringBuilder 创建 StringBuilder：\nStringBuilder sb = new StringBuilder(); 在末尾添加字符或字符串：\nsb.append(char); 在末尾删除字符：\nsb.deleteCharAt(sb.length() - 1); 长度：\nsb.length(); 转化为 String：\nsb.toString(); 取反：\nsb.reverse(); 插入：\nsb.insert(0, \u0026#34;abcd\u0026#34;);\t// 在第0个元素插入\u0026#34;abcd\u0026#34; 清空：\nsb.setLength(0); 取字符：\nsb.charAt(i); 修改位置的字符：\nsb.setCharAt(i); Queue 创建queue:\nQueue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;Integer\u0026gt;(); 加入元素：\nqueue.offer(1); 删除元素（先进先出）：\nqueue.poll(); 队首元素：\nqueue.peek(); 队列大小：\nqueue.size(); 是否为空：\nqueue.isEmpty(); 队列清空：\nqueue.clear(); Deque 创建Deque：\nDeque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;Integer\u0026gt;(); 队尾添加元素：\ndeque.offerLast();\t// queue的用法 队首弹出元素：\ndeque.pollFirst();\t// queue的用法 取队首元素：\ndeque.peekFirst();\t// queue的用法 队首添加元素：\ndeque.offerFirst(); 队尾弹出元素：\ndeque.pollLast(); 取队尾元素：\ndeque.peekLast(); LinkedList 新建链表：\nLinkedList\u0026lt;Integer\u0026gt; link = new LinkedList\u0026lt;Integer\u0026gt;(); 末尾插入：\nlink.add(); // 注意这个函数返回boolean，因此不要重复赋值 link.addLast(); // 返回void 指定位置插入：\nlink.add(int index, int Ele); 头部插入：\nlink.addFirst(); 清空：\nlink.clear(); 删除并返回第一个：\nlink.removeFirst(); 删除并返回最后一个：\nlink.removeLast(); 删除特定位置：\nlink.remove(int index) 重设：\nlink.set(); 头部取值：\nlink.getFirst(); 尾部取值：\nlink.getLast(); 特定位置取值：\nlink.get(int index); 是否存在：\nlink.contains(int key); PriorityQueue: 创建优先队列：\nPriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;Integer\u0026gt;(); // 如果不加Comparator默认为小根堆 // 即只有第一个元素是最小元素 插入元素：\nheap.offer(); 取堆顶：\nheap.peek(); 弹出堆顶：\nheap.poll(); 删除特定元素：\nheap.remove(); 堆大小：\nheap.size(); 互相转换 // int转String int i; String str = String.valueOf(i); // String转int String str; int i = Integer.parseInt(str); // char转int char ch; int i = ch - \u0026#39;0\u0026#39;; // int转char int i; char ch = (char) (i + \u0026#39;0\u0026#39;); // String转char[] String str; char[] ch = str.toCharArray(); // char[]转String char[] ch; String str = String.valueOf(ch); // char转String char ch = \u0026#39;a\u0026#39;; String str = ch + \u0026#34;\u0026#34;; // ArrayList转Integer[] List\u0026lt;Integer\u0026gt; list; Integer[] array = list.toArray(new Integer[list.size()]); // Integer[]转ArrayList Integer[] array; List\u0026lt;Integer\u0026gt; list = Arrays.asList(array); 坑 Math.ceil：\ndouble Math.ceil(double a);\t// 原函数 Math.ceil(24 / 23);\t// 1.0 Math.ceil(22 / 23);\t// 0.0 Math.ceil((double) 24 / 23);\t// 2.0 (int) Math.ceil((double) 24 / 23);\t// 2 Math.pow:\nMath.pow(10, 9);\t// 如果想求次方必须要用pow函数，返回double 10 ^ 9;\t// 这里表示的是亦或而不是次方 二维数组：\nint[][] a = new int[][] {{1, 2}, {3, 4}}; int[] b = a[1];\t// b = [3, 4] b[1] = 100; // a = [[1, 2], [3, 100]] ","permalink":"https://kyxie.github.io/zh/blog/tech/java/","summary":"Character 判断是否为字母或数字： boolean res = Character.isLetterOrDigit(char); 转小写： char res = Character.toLowerCase(char); 下一个字符： \u0026#39;b\u0026#39; == (char) (\u0026#39;a\u0026#39; + 1); Integer 最大值最小值： int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; 比较相等： Integer a = 1; Integer b = 1; a == b; // true","title":"Java"},{"content":"char 转大小写：\nchar ch = \u0026#39;a\u0026#39;; ch = (char) toupper(ch); ch = (char) tolower(ch); 下一个字符：\n\u0026#39;b\u0026#39; == (\u0026#39;a\u0026#39; + 1); int 最大值最小值：\nint MAX = INT_MAX; int MIN = INT_MIN; array 创建数组：\nint array [4];\t// 如果不初始化则值随机 int array[] = {1,2,3,4}; int array[4] = {0};\t// {0, 0, 0, 0} // 注意只有0可以这样被初始化，其他的数是不行的 int array[4] = {1};\t// {1, 0, 0, 0}，只有第一个数被初始化为1，其他的还是默认值 引用：\narray[3]; 获取长度：\nsizeof(array) / sizeof(array[0]); 排序：\n#include \u0026lt;algorthm\u0026gt; int a[] = {5, 4, 3, 2, 1}; int n = sizeof(a) / sizeof(a[0]); // 升序 sort(a, a + n); // 降序 bool compare(int a, int b) { return a \u0026gt; b;\t// 若改为a \u0026lt; b则为升序 } sort(a, a + n, compare); string 创建字符串：\nstring s = \u0026#34;cpp\u0026#34;; 引用\ns[0]\t// s[0] = \u0026#39;c\u0026#39; 字符串相等：\nstring s1 = \u0026#34;abc\u0026#34;; string s2 = \u0026#34;abc\u0026#34;; s1.compare(s2); // 若s1小于s2返回-1 // 若相等返回0 // 若s1大于s2返回1 字符串长度：\nint n = s.size(); 字符串连接：\ns1.append(s2); 截取字符串：\nstring s = \u0026#34;abc\u0026#34;; string sub = s.substr(0, 1);\t// str = \u0026#34;a\u0026#34;; 字符的位置：\nstring s = \u0026#34;abc\u0026#34;; s.find(\u0026#39;a\u0026#39;);\t// 从前向后查找第一个出现的\u0026#39;a\u0026#39;的位置 s.rfind(\u0026#39;a\u0026#39;);\t// 从后往前查找第一个出现的\u0026#39;a\u0026#39;的位置 s.find_first_of(\u0026#34;abc\u0026#34;);\t// 从前往后查找第一次出现在\u0026#34;abc\u0026#34;中任意字符的位置 s.find_last_of(); s.find_first_not_of(); s.find_last_not_of(); // 如果没有查询到则返回： string::npos 插入字符串：\nstring s1 = \u0026#34;abc\u0026#34;; s1.insert(1, \u0026#34;ddd\u0026#34;);\t// s1 = \u0026#34;adddbc\u0026#34; 字符串交换：\ns1.swap(s2); 字符串替换：\nstring s = \u0026#34;a! b\u0026#34;; replace(s.begin(), s.end(), \u0026#39;!\u0026#39;, \u0026#39; \u0026#39;);\t// str = \u0026#34;a b\u0026#34;; 删除字符串头尾的空格：\nstring trim(string s) { if (s.empty()) { return s; } s.erase(0, s.find_first_not_of(\u0026#34; \u0026#34;)); s.erase(s.find_last_not_of(\u0026#34; \u0026#34;) + 1); return s; } 字符串修改：\nstring s = \u0026#34;apple\u0026#34;; s[0] = \u0026#39;b\u0026#39;; 字符串删除：\nstring s = \u0026#34;apple\u0026#34;; s.erase(bit, num);\t// bit表示开始的删除的位，num表示要删除的字符的个数 vector 定义vector：\n// 一维 vector\u0026lt;int\u0026gt; vec; vector\u0026lt;int\u0026gt; vec(3);\t// 默认值为0 // 利用数组初始化 int arr[] = {1, 2, 3}; vector\u0026lt;int\u0026gt; vec(begin(arr), end(arr)); // 二维 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec(m, vector\u0026lt;int\u0026gt;(n));\t// 长为m，宽为n 排序：\nsort(vec.begin(), vec.end());\t// 升序 sort(vec.rbegin(), vec.end());\t// 降序 取栈顶：\nvec.back(); 判断是否存在：\nif (find(vec.begin(), vec.end(), key) != vec.end()) { // != 表示存在 } 删除元素：\nvec.erase(vec.begin() + index);\t// 删除第index个元素 判断是否为空：\nvec.empty(); 清空列表：\nvec.clear(); 反转：\nvec.reverse(vec.begin(), vec.end()); 二维排序：\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec{{3, 4}, {1, 2}, {5, 6}}; // 按照第一列，升序排列 sort(vec.begin(), vec.end()); // 若不是，则需要写排序规则 bool compare(const vector\u0026lt;int\u0026gt; \u0026amp;a, const vector\u0026lt;int\u0026gt; \u0026amp;b) { return a[1] \u0026lt; b[1];\t// 按照第二列升序 } pair 创建：\npair\u0026lt;int, int\u0026gt; p; pair\u0026lt;int, int\u0026gt; p(p1, p2); make_pair(p1, p2); 取值：\np1.first;\t// 第一个元素 p1.second;\t// 第二个元素 pair作为函数返回值：\nstd::pair\u0026lt;std::string, std::int\u0026gt; getPerson() { return std::make_pair(\u0026#34;Kyxie\u0026#34;, 1); } std::tie(p1, p2) = getPerson(); unordered_map 创建一个哈希映射：\n#include \u0026lt;unordered_map\u0026gt; unordered_map \u0026lt;int, int\u0026gt; map; 存储键值对（修改键值对）：\nmap.insert(pair\u0026lt;int, int\u0026gt;(key, value)); map[key] = value;\t// 这种更简单 获取 key 的内容：\nmap[key]; 查询是否存在 key：\nmap.count(key);\t// 如果存在，返回1，不存在则返回0 if ((auto iter = map.find(key)) != map.end());\t// 存在则括号内为真 // iter的数据类型为 unordered_map\u0026lt;int, int\u0026gt;::iterator if (map[key] == 0)\t// 这种最简单 遍历键值对：\nfor (auto i = map.begin(); i != map.end(); i++) { // key: i-\u0026gt;first // value: i-\u0026gt;second } 是否为空：\nmap.empty(); 删除Key：\nmap.erase(key); map的大小：\nmap.size(); unordered_set 遍历：\nfor (auto i = set.begin(); i != set.end(); i++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; endl; } queue 创建queue:\nqueue\u0026lt;int\u0026gt; q; 加入元素：\nq.push(1); 删除队首元素：\nq.pop();\t// 这个没有返回值 队首元素：\nq.front(); 队列大小：\nq.size(); 是否为空：\nq.empty(); 互相转换 // int转string int i; string str = to_string(i); // string转int String str; int i = stoi(str); // char转int char ch; int i = ch - \u0026#39;0\u0026#39;; // int转char int i; char ch = i + \u0026#39;0\u0026#39;; // char[]转int char s[] = \u0026#34;111\u0026#34;; int i = atoi(s); // int转char[] int i = 111; char ch[100]; itoa(i, ch, 10); // 第一个参数为待转化的整数 // 第二个参数为输出的字符串数组 // 第三个参数为进制，范围为2 - 36 // String转char[] string str; char *ch = (char *)str.data(); // char[]转String char ch[] = \u0026#34;abcd\u0026#34;; string str(ch); // char转String char ch = \u0026#39;a\u0026#39;; string str(1, ch); // int[]转vector int a[] = {1, 2, 3}; vector\u0026lt;int\u0026gt; vec(a, a + sizeof(a) / sizeof(int)); // vector转int[] vector\u0026lt;int\u0026gt; vec{1, 2, 3}; int i[vec.size()]; memcpy(i, \u0026amp;vec[0], vec.size() * sizeof(vec[0])); ","permalink":"https://kyxie.github.io/zh/blog/tech/cpp/","summary":"char 转大小写： char ch = \u0026#39;a\u0026#39;; ch = (char) toupper(ch); ch = (char) tolower(ch); 下一个字符： \u0026#39;b\u0026#39; == (\u0026#39;a\u0026#39; + 1); int 最大值最小值： int MAX = INT_MAX; int MIN = INT_MIN; array 创建数组： int array [4]; // 如果不初始化则值随机 int array[] = {1,2,3,4}; int","title":"Cpp"},{"content":"前言 我就喜欢搞一些简洁而又花里胡哨的东西。\n教程基于Windows 11自带的Terminal。\n字体 我使用的字体是CodeNewRoman Nerd Font，这个字体同样是我博客的字体，可以从这里下载，下载后安装即可，也可以在VS Code上使用这个字体。\n下载 oh-my-posh winget install JanDeDobbeleer.OhMyPosh 终端设置 我这里直接修改了Windows PowerShell的配置，如果不想破坏默认的配置也可以新建一个配置文件。\n在配色方案的选项下，我选择的Campbell，但是我打开设置的json file里面把第一个主题的background改成了#0C0C0C，避免了纯黑的背景。\n在Windows PowerShell的常规选项下，取消勾选使用父进程目录，在外观选项下选取下载的字体CodeNowRoman Nerd Font。\n文件配置 在终端输入\necho $profile 找到这个文件，如果找不到自己新建一个。\n从这里选择一个自己喜欢的主题，点击主题名字进入相应的github并且下载.json源码，保存在本地，粘贴下面语句到这个文件中，修改路径为你保存的路径。\noh-my-posh init pwsh --config \u0026#39;C:/Users/Posh/jandedobbeleer.omp.json\u0026#39; | Invoke-Expression 保存后运行：\n. $profile FAQ 如果运行失败，可能需要更新PSReadLine。\n如果识别不了icon，大概率字体的问题，查看是否在PowerShell的页面下设置字体为Nerd字体。\n效果展示 ","permalink":"https://kyxie.github.io/zh/blog/tech/bash/","summary":"前言 我就喜欢搞一些简洁而又花里胡哨的东西。 教程基于Windows 11自带的Terminal。 字体 我使用的字体是CodeNewRoman Nerd Fo","title":"Windows 11 打造个性化终端"},{"content":"\rKyxie\u0026#39;s Blog\rHello World Printer\rSulv’s Blog\r记录技术、阅读、生活的博客\r友链格式：\nname=\u0026#34;Kyxie\u0026#39;s Blog\u0026#34; url=\u0026#34;https://kyxie.github.io/zh\u0026#34; logo=\u0026#34;https://kyxie.github.io/Avatar.png\u0026#34; word=\u0026#34;Hello World Printer\u0026#34; ","permalink":"https://kyxie.github.io/zh/links/","summary":"Kyxie\u0026#39;s Blog Hello World Printer Sulv’s Blog 记录技术、阅读、生活的博客 友链格式： name=\u0026#34;Kyxie\u0026#39;s Blog\u0026#34; url=\u0026#34;https://kyxie.github.io/zh\u0026#34; logo=\u0026#34;https://kyxie.github.io/Avatar.png\u0026#34; word=\u0026#34;Hello World Printer\u0026#34;","title":"友链 🤝"},{"content":"👉️填写QQ邮箱可以自动获取QQ头像哦\n","permalink":"https://kyxie.github.io/zh/comment/comments/","summary":"👉️填写QQ邮箱可以自动获取QQ头像哦","title":"留言板 📋"},{"content":"\n","permalink":"https://kyxie.github.io/zh/blog/life/music/","summary":"","title":"最近爱听"},{"content":" 研究生项目 Turbo Wallet - 记账软件 2022年1月 至 2022年3月，JavaScript\nGitHub (前端仓库): https://github.com/Kyxie/money-management.git\nGitHub (后端仓库): https://github.com/Kyxie/money-back.git\n这是一个帮助我们记录每天生活花费的手机App。 前端基于React.js框架，后端基于Express.js框架，数据库基于MongoDB。 可以添加，编辑和删除每一条消费记录，并且App会生成一些折线图和饼图帮助我们分析近期的消费。 还可以直观地看到哪一种消费花了多少钱，以及不同种类的消费的排序。 交通监视系统 2021年9月 至 2021年12月，Python / C++\nGitHub: https://github.com/Kyxie/Traffic.git\n这个项目帮助当地警察局在道路交叉口安装最少的摄像头，但是获得最大的监控覆盖面积。这是一个顶点覆盖问题，我们利用CNF-SAT来对这个问题进行优化。 使用Python生成一张包含城市交通细节的地图(道路和十字路口)，然后尝试使用迪杰斯特拉算法在城市中找到最短路径，最后，我们利用CNF-SAT模拟安装摄像头是否能覆盖城市所有街道，解决顶点覆盖问题。 该项目实现了多线程和并行处理，以更高效地运行。 我的个人网站 2021年8月 至 今，HTML / CSS / JavaScript\nGitHub: https://github.com/Kyxie/Kyxie.github.io.git\n这个项目是基于Hugo的PaperMod主题。 本科项目 基于深度学习的行人重识别系统 2020年9月 至 2021年6月，Python\nGitHub: https://github.com/Kyxie/ReID-deep-learning.git\n本项目是基于深度学习方法的行人重识别系统，所使用的框架是PyTorch。 我们利用Market-1501数据集去训练模型，然后利用这个数据集和我们自创的UESTC Re-ID数据集去测试模型。 本项目的深度学习模型为ResNet-50，损失函数为TriHard损失。 对于Market-1501数据集的mAP指标达到58.8%，rank@1指标达到76.3%。 信道分配系统 2021年4月 至 2021年5月，MATLAB\nGitHub: https://github.com/Kyxie/Channels.git\n这是一个关于信道分配问题的项目，项目背景为在医院中，将最高信噪比的信道分配给最需要的人（例如病人），而将普通人分配给病人的干扰信道（信噪比低）。 我们提出了4种算法去实现这个问题。 Webots机器人 2020年2月 至 2020年6月，C++\nGitHub: https://github.com/Kyxie/TDPS-2020-UESTC-Glasgow.git\nBilibili: https://www.bilibili.com/video/BV1Rp4y1S7o3?from=search\u0026amp;seid=72774621551842110\n\u003c!DOCTYPE HTML\u003e\r这是一个基于Webots的项目。 我们在Webots软件中设计了一个智能小车和完成任务需要的场地，我们为小车安装了惯性导航模块，LIDAR模块和摄像头模块使得小车可以完成巡线，姿态解算，颜色识别等任务。 基于FPGA的波形发生器 2019年9月 至 2019年12月, Verilog\nGitHub: https://github.com/Kyxie/wave-generator.git\n利用FPGA (Xilinx xc7a35tftg256)来生成正弦波，三角波和方波。 波的频率可调，从0 - 255Hz，并由8位USART控制。 利用4个拨码开关来控制振幅，从0 - 1V，分辨率为0.1V。 利用2个拨码开关来选择波形。 输出结果可通过VGA显示，可显示相应波形的图像信息和频率、幅值。 一个RISC架构的CPU 2018年2月 至 2018年6月, Verilog\nGitHub: https://github.com/Kyxie/CPU.git\n使用Quartus II软件实现RISC CPU，使其能够进行加、减、乘、除操作。 CPU的设计包含数据路径模块设计（ALU，寄存器和PC），控制单元设计（状态转换和IR）以及这两个模块之间的通信（CPU的集成）。 ","permalink":"https://kyxie.github.io/zh/projects/","summary":"研究生项目 Turbo Wallet - 记账软件 2022年1月 至 2022年3月，JavaScript GitHub (前端仓库): https://github.com/Kyxie/money-management.git GitHub (后端仓库): https://github.com/Kyxie/money-back.git 这是一个帮助我们记录每天生活","title":"项目 👨‍💻"},{"content":"class Me: def __init__(self): self.name = \u0026#34;Kunyang Xie\u0026#34; self.prefer_name = \u0026#34;Kyrie\u0026#34; self.born_year = 1999 self.MBTI = ISTJ self.hometown = \u0026#34;Weifang, Shandong, CN\u0026#34; self.curr_location = \u0026#34;Richmond Hill, ON, CA\u0026#34; self.grad_school = \u0026#34;uWaterloo\u0026#34; self.undergrad_school = \u0026#34;UESTC, UofG\u0026#34; ","permalink":"https://kyxie.github.io/zh/about/","summary":"class Me: def __init__(self): self.name = \u0026#34;Kunyang Xie\u0026#34; self.prefer_name = \u0026#34;Kyrie\u0026#34; self.born_year = 1999 self.MBTI = ISTJ self.hometown = \u0026#34;Weifang, Shandong, CN\u0026#34; self.curr_location = \u0026#34;Richmond Hill, ON, CA\u0026#34; self.grad_school = \u0026#34;uWaterloo\u0026#34; self.undergrad_school = \u0026#34;UESTC, UofG\u0026#34;","title":"关于我 👋"}]